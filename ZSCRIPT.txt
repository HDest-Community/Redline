version "4.0"

class RedlineHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'PlasmaReplaces':
				if (random[redrand]() <= 32)
				{
					e.Replacement = "RedlineRandom";
				}
				break;
		}
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let RedlineAmmo = HDBattery(e.Thing);
		if (RedlineAmmo)
		{
			RedlineAmmo.ItemsThatUseThis.Push("HDRedline");
		}
	}
}

class HDRedline : HDCellWeapon
{
	enum RedlineFlags
	{
		RDF_HeatSink = 1,
		RDF_Scope = 2,
		RDF_Overheated = 4
	}

	enum RedlineProperties
	{
		RDProp_Flags,
		RDProp_Battery,
		RDProp_LoadType,
		RDProp_Gear,
		RDProp_Rpm,
		RDProp_Heat
	}

	override void PostBeginPlay()
	{
		weaponspecial = 1337; // [Ace] UaS sling compatibility.

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		WeaponStatus[RDProp_Rpm] = int(WeaponStatus[RDProp_Rpm] * (0.990 - 0.001 * WeaponStatus[RDProp_Gear]));
		WeaponStatus[RDProp_Rpm] = max(0, WeaponStatus[RDProp_Rpm] - 1);

		if (WeaponStatus[RDProp_Heat] > 0)
		{
			if (WeaponStatus[RDProp_Flags] & RDF_HeatSink)
			{
				WeaponStatus[RDProp_Heat]--;
			}
			DrainHeat(RDProp_Heat);
		}
		if (WeaponStatus[RDProp_Heat] <= 0)
		{
			WeaponStatus[RDProp_Flags] &= ~RDF_Overheated;
		}
		Super.Tick();
	}

	override void DoEffect()
	{
		if (!owner || !owner.player || owner.player.ReadyWeapon != self)
		{
			return;
		}

		// Console.Printf("\c[Green]RPM:\c- %i \c[Green]Gear:\c- %i \c[Green]Heat:\c- %i",
		// 	WeaponStatus[RDProp_Rpm],
		// 	WeaponStatus[RDProp_Gear],
		// 	WeaponStatus[RDProp_Heat]);

		int btn = owner.player.cmd.buttons;
		int oldbtn = owner.player.oldbuttons;
		bool PressedFiremode = btn & BT_FIREMODE && !(oldbtn & BT_FIREMODE);

		if (PressedFiremode && WeaponStatus[RDProp_Gear] > 0)
		{
			owner.A_StartSound("Redline/GearDown", 5, CHANF_OVERLAP);
			WeaponStatus[RDProp_Gear]--;
			if (WeaponStatus[RDProp_Rpm] > 30)
			{
				WeaponStatus[RDProp_Rpm] += 200;
			}
			A_CheckOverheat();
		}

		Super.DoEffect();
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner , bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override double GunMass() { return WeaponStatus[RDProp_Battery] >= 0 ? 12 : 11; }
	override double WeaponBulk()
	{
		return 122
		+ (WeaponStatus[RDProp_Battery] >= 0 ? ENC_BATTERY_LOADED : 0)
		+ (WeaponStatus[RDProp_Flags] & RDF_Scope ? 6 : 0);
	}
	override string, double GetPickupSprite() { return WeaponStatus[RDProp_Flags] & RDF_Scope ? "RDSGZ0" : "RDNGZ0", 1.0; }
	override void InitializeWepStats(bool idfa)
	{
		WeaponStatus[RDProp_Battery] = 40;
	}
	override void LoadoutConfigure(string input)
	{
		if (GetLoadoutVar(input, "sink", 1) > 0)
		{
			WeaponStatus[RDProp_Flags] |= RDF_HeatSink;
		}
		if (GetLoadoutVar(input, "scope", 1) > 0)
		{
			WeaponStatus[RDProp_Flags] |= RDF_Scope;
		}

		InitializeWepStats(false);
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Shoot\n"
		..WEPHELP_ALTFIRE.."  Shift gear up\n"
		..WEPHELP_FIREMODE.." Shift gear down\n"
		..WEPHELP_ALTFIRE.." (hold)+"..WEPHELP_RELOAD.."  Load/Unload battery\n"
		..WEPHELP_ALTFIRE.." (hold)+"..WEPHELP_UNLOAD.."  Unload battery";
	}

	override string PickupMessage()
	{
		string SinkStr = WeaponStatus[RDProp_Flags] & RDF_HeatSink ? "heat-sinked " : "";
		return String.Format("You got the %sRDL-N3 'Redline' bolt-action thermal lance.", SinkStr);
	}

	protected clearscope int GetRealBatteryCharge(bool useUpper)
	{
		if (WeaponStatus[RDProp_Battery] == -1)
		{
			return -1;
		}
		double FracCharge = WeaponStatus[RDProp_Battery] / 2.0;
		return int(useUpper ? ceil(FracCharge) : floor(FracCharge));
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		if (sb.HudLevel == 1)
		{
			sb.DrawBattery(-54, -4, sb.DI_SCREEN_CENTER_BOTTOM, reloadorder: true);
			sb.DrawNum(hpl.CountInv("HDBattery"), -46, -8, sb.DI_SCREEN_CENTER_BOTTOM);
		}

		int BatteryCharge = GetRealBatteryCharge(true);
		if (BatteryCharge > 0)
		{
			sb.DrawWepNum(hdw.WeaponStatus[RDProp_Rpm], MaxRpm, posy: -7, alwaysprecise: true);
			sb.DrawWepNum(BatteryCharge, 20, posy: -4);
		}
		else if (BatteryCharge == 0)
		{
			sb.DrawString(sb.mAmountFont, "00000", (-16, -9), sb.DI_TEXT_ALIGN_RIGHT | sb.DI_SCREEN_CENTER_BOTTOM, Font.CR_DARKGRAY);
		}

		for (int i = 0; i < hdw.WeaponStatus[RDProp_Gear]; ++i)
		{
			sb.DrawRect(-17 - 2 * i, -12, 1, 2);
		}

		if (hdw.WeaponStatus[RDProp_Rpm] > MaxRpm)
		{
			sb.DrawString(sb.pNewSmallFont, "OVERHEAT", (-24, -26), sb.DI_TEXT_ALIGN_RIGHT | sb.DI_SCREEN_CENTER_BOTTOM, Font.CR_RED, scale: (0.75, 0.75));
		}
	}

	override void DrawSightPicture(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl, bool sightbob, vector2 bob, double fov, bool scopeview, actor hpc, string whichdot)
	{
		int cx, cy, cw, ch;
		int ScaledYOffset = 48;
		int ScaledWidth = 89;

		[cx, cy, cw, ch] = Screen.GetClipRect();
		sb.SetClipRect(-16 + bob.x, -4 + bob.y, 32, 16, sb.DI_SCREEN_CENTER);
		vector2 bob2 = bob * 2;
		bob2.y = clamp(bob2.y, -8, 8);
		sb.DrawImage("REDFRONT", bob2, sb.DI_SCREEN_CENTER | sb.DI_ITEM_TOP, alpha: 0.9, scale: (1, 0.6));
		sb.SetClipRect(cx, cy, cw, ch);
		sb.DrawImage("REDBACK", bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_TOP, scale: (1.25, 0.85));

		if (hdw.WeaponStatus[RDProp_Flags] & RDF_Scope && scopeview)
		{
			TexMan.SetCameraToTexture(hpc, "REDLNCAM", 4);
			sb.DrawImage("REDLNCAM",(0, ScaledYOffset) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER);
			sb.DrawImage("RDLNSCOP",(0, ScaledYOffset) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER);
			bob2 *= 3;
			double DotOffset = max(abs(bob2.x), abs(bob2.y));
			if (DotOffset < 20)
			{
				sb.DrawImage("RDLNSGHT", (0, ScaledYOffset) + bob2 * 3, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, alpha: 0.8 - DotOffset * 0.12);
			}
		}
	}

	private action void A_CheckOverheat()
	{
		if (invoker.WeaponStatus[RDProp_Rpm] > MaxRpm)
		{
			invoker.WeaponStatus[RDProp_Heat] += 70 + 30 * invoker.WeaponStatus[RDProp_Gear];
			invoker.WeaponStatus[RDProp_Flags] |= RDF_Overheated;
			A_StartSound("Redline/Overload", 6);
		}
	}

	const MaxGear = 4;
	const MaxRpm = 1200;

	Default
	{
		-HDWEAPON.FITSINBACKPACK
		Weapon.SelectionOrder 300;
		Weapon.SlotNumber 6;
		Weapon.SlotPriority 1.5;
		HDWeapon.BarrelSize 35, 1.5, 2;
		Scale 0.6;
		Tag "RDL-N3 'Redline' Thermal Lance";
		HDWeapon.Refid "rdl";
	}

	States
	{
		Spawn:
			RDSG Z 0 NoDelay A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG Z 0;
			#### Z -1;
			Stop;
		Ready:
			RDSG A 0 A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG A 0;
			#### A 1 A_WeaponReady(WRF_ALL & ~(WRF_ALLOWUSER1 | WRF_ALLOWUSER2));
			Goto ReadyEnd;
		Select0:
			RDSG A 0 A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG A 0;
			#### A 0;
			Goto Select0Big;
		Deselect0:
			RDSG A 0 A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG A 0;
			#### A 0;
			Goto Deselect0Big;
		User3:
			#### A 0 A_MagManager("HDBattery");
			Goto Ready;
		Fire:
			#### A 0
			{
				if (invoker.WeaponStatus[RDProp_Battery] <= 0)
				{
					SetWeaponState('Nope');
					return;
				}

				if (invoker.WeaponStatus[RDProp_Rpm] < 100 * invoker.WeaponStatus[RDProp_Gear] || invoker.WeaponStatus[RDProp_Flags] & RDF_Overheated)
				{
					A_StartSound("Redline/Overheated", CHAN_WEAPON);
					SetWeaponState('Nope');
					return;
				}
			}
			#### F 1 Bright Offset(0, 42)
			{
				A_Light0();
				A_StartSound("Redline/Fire", CHAN_WEAPON);

				int Gear = invoker.WeaponStatus[RDProp_Gear];
				int DamageDealt = int(random(90, 120) ** (1.0 + 0.06 * Gear));
				A_RailAttack(DamageDealt, 0, false, "", "", RGF_NOPIERCING | RGF_NORANDOMPUFFZ | RGF_SILENT, 0, "RedlineRayImpact", 0, 0, 12600, 0, 4.0, 0, "RedlineRaySmoke");
				
				invoker.WeaponStatus[RDProp_Heat] += 5 + 5 * invoker.WeaponStatus[RDProp_Gear];
				A_CheckOverheat(); // [Ace] Only overheat if firing while redlining.
				invoker.WeaponStatus[RDProp_Rpm] = int(invoker.WeaponStatus[RDProp_Rpm] + DamageDealt * (1.0 - 0.2 * Gear) * (AceCore.CheckForItem(self, "HDGungnir") ? 3.5 : 4));
				A_AlertMonsters();
				A_MuzzleClimb(0, 0, -0.2, -0.8, -frandom(0.5, 0.9), -frandom(0.5, 0.9), -frandom(0.5, 0.9), -frandom(0.5, 0.9));
				invoker.WeaponStatus[RDProp_Battery] -= 1;
			}
			#### A 2 Offset(0, 38);
			#### A 1 Offset(0, 34);
			Goto Nope;
		AltFire:
			#### A 1 Offset(0, 34) A_WeaponBusy();
			#### B 1 Offset(4, 38);
			#### B 1 Offset(0, 34);
			#### B 0 A_Refire('BoltPull');
			Goto Ready;
		BoltPull:
			#### C 2 Offset(4, 38) A_StartSound("Redline/BoltBack", 8, CHANF_OVERLAP);
			#### D 1 Offset(6, 42)
			{
				if (GunBraced())
				{
					A_MuzzleClimb(frandom(-0.1, 0.3), frandom(-0.1, 0.3));
				}
				else
				{
					A_MuzzleClimb(frandom(-0.2, 0.8), frandom(-0.4, 0.8));
				}
				if (invoker.WeaponStatus[RDProp_Battery] == 0)
				{
					A_StartSound("Redline/Eject", 9, pitch: 0.7);
					Actor Mag = HDMagAmmo.SpawnMag(self, "HDBattery", 0);
					Mag.Angle = Angle;
					Mag.A_ChangeVelocity(-0.75, -1.5, 3.5, CVF_RELATIVE);
					invoker.WeaponStatus[RDProp_Battery] = -1;
				}

				if (invoker.WeaponStatus[RDProp_Battery] > 0 && invoker.WeaponStatus[RDProp_Gear] < MaxGear)
				{
					A_StartSound("Redline/GearUp", 5, CHANF_OVERLAP);
					invoker.WeaponStatus[RDProp_Gear]++;
					invoker.WeaponStatus[RDProp_Rpm] -= int(invoker.WeaponStatus[RDProp_Rpm] * (0.6 - 0.1 * invoker.WeaponStatus[RDProp_Gear]));
				}
			}
			#### E 2 Offset(6, 42);
			#### E 1 Offset(6, 42) A_WeaponReady(WRF_NOFIRE);
			#### E 0 A_Refire("AltHold");
			Goto AltHoldEnd;
		AltHold:
			#### E 1 A_WeaponReady(WRF_NOFIRE);
			#### E 1
			{
				A_ClearRefire();
				if ((PressingReload() || PressingUnload()) && invoker.WeaponStatus[RDProp_Battery] >= 0)
				{
					invoker.WeaponStatus[RDProp_LoadType] = 0; // [Ace] Unload.
					SetWeaponState('LoadChamber');
					return;
				}
				else if (PressingReload() && CheckInventory("HDBattery", 1))
				{
					invoker.WeaponStatus[RDProp_LoadType] = 1;
					SetWeaponState('LoadChamber');
					return;
				}

				if (PressingAltFire())
				{
					SetWeaponState('AltHold');
					return;
				}
			}
		AltHoldEnd:
			#### D 2 A_StartSound("Redline/BoltFwd", 8, CHANF_OVERLAP);
			#### C 2;
			#### B 2 Offset(2, 36)
			{
				A_WeaponReady(WRF_NOFIRE);
				A_WeaponBusy(false);
			}
			Goto Ready;
		LoadChamber:
			#### E 1 Offset(2, 36) A_ClearRefire();
			#### E 1 Offset(3, 38);
			#### E 1 Offset(5, 42);
			#### E 1 Offset(8, 48) A_StartSound("weapons/pocket", 9);
			#### E 1 Offset(9, 52) A_MuzzleClimb(frandom(-0.2, 0.2), 0.2, frandom(-0.2, 0.2), 0.2, frandom(-0.2, 0.2), 0.2);
			#### E 2 Offset(8, 60);
			#### E 2 Offset(7, 72);
			#### E 2 Offset(6, 80);
			#### E 15;
			#### E 4
			{
				switch (invoker.WeaponStatus[RDProp_LoadType])
				{
					case 0:
						int BatteryCharge = invoker.GetRealBatteryCharge(false); // [Ace] Lose fractions if you take out a non-empty battery.
						invoker.WeaponStatus[RDProp_Battery] = -1;
						if (A_JumpIfInventory("HDBattery", 0, "null"))
						{
							HDMagAmmo.SpawnMag(self, "HDBattery", BatteryCharge);
						}
						else
						{
							HDMagAmmo.GiveMag(self, "HDBattery", BatteryCharge);
						}
						A_StartSound("Redline/CellOut", 10);
						break;
					case 1:
						let Battery = HDMagAmmo(FindInventory("HDBattery"));
						if (Battery && Battery.Amount > 0)
						{
							invoker.WeaponStatus[RDProp_Battery] = Battery.TakeMag(true) * 2;
							A_StartSound("Redline/CellIn", 10);
						}
						break;
				}
			}
			#### E 2 Offset(6, 80);
			#### E 2 Offset(7, 72);
			#### E 2 Offset(8, 60);
			#### E 1 Offset(7, 52);
			#### E 1 Offset(5, 42);
			#### E 1 Offset(3, 38);
			#### E 1 Offset(3, 35);
			Goto AltHold;
	}
}

class RedlineRandom : IdleDummy
{
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SpawnItemEx("HDBattery", -3,flags: SXF_NOCHECKPOSITION);
				let wpn = HDRedline(Spawn("HDRedline", pos, ALLOW_REPLACE));
				if (!wpn)
				{
					return;
				}

				wpn.special = special;
				for (int i = 0; i < 5; ++i)
				{
					wpn.Args[i] = Args[i];
				}
				if (!random(0, 3))
				{
					wpn.WeaponStatus[wpn.RDProp_Flags] |= wpn.RDF_HeatSink;
				}
				if (!random(0, 3))
				{
					wpn.WeaponStatus[wpn.RDProp_Flags] |= wpn.RDF_Scope;
				}

				wpn.InitializeWepStats(false);
			}
			Stop;
	}
}

class RedlineRayImpact : HDActor
{
	Default
	{
		+NODAMAGETHRUST
		+FORCEDECAL
		+PUFFGETSOWNER
		+ALWAYSPUFF
		+PUFFONACTORS
		+NOINTERACTION
		+BLOODLESSIMPACT
		+FORCERADIUSDMG
		+NOBLOOD
		Decal "RedlineScorch";
		DamageType "Thermal";
	}

	States
	{
		Spawn:
			TNT1 A 5 NoDelay
			{
				A_Explode(random(15, 30), 20, XF_HURTSOURCE, false);
				A_StartSound("Redline/Impact");

				for (int i = 0; i < 30; ++i)
				{
					double pitch = frandom(-85.0, 85.0);
					A_SpawnParticle(0xFF1111, SPF_RELATIVE | SPF_FULLBRIGHT, random(10, 20), random(5, 8), random(0, 359), random(0, 4), 0, 0, random(1, 5) * cos(pitch), 0, random(1, 5) * sin(pitch), 0, 0, -0.5);
				}
			}
			Stop;
	}
}

class RedlineRaySmoke : Actor
{
	override void PostBeginPlay()
	{
		if (!random(0, 2))
		{
			A_SpawnItemEx("RedlineRaySmokeParticle");
		}

		A_SetRoll(random(0, 360));

		Super.PostBeginPlay();
	}

	Default
	{
		StencilColor "FF1111";
		RenderStyle "Stencil";
		+NOINTERACTION
		+ROLLSPRITE
		Alpha 2.0;
		Scale 0.005;
	}

	States
	{
		Spawn:
			RDSM K 1 Bright
			{
				A_FadeOut(0.1);
				A_SetScale(Scale.X + 0.0001);
				A_ChangeVelocity(frandom(-0.0025, 0.0025), frandom(-0.0025, 0.0025), frandom(-0.0025, 0.0025), CVF_RELATIVE);
			}
			Loop;
	}
}

class RedlineRaySmokeParticle : Actor
{
	override void PostBeginPlay()
	{
		Lifetime = DefaultLifeTime = random(25, 40);
		ParticleSize = frandom(2.0, 3.0);

		Super.PostBeginPlay();
	}

	Default
	{
		+NOINTERACTION
	}

	double Lifetime;
	double DefaultLifeTime;
	double ParticleSize;

	States
	{
		Spawn:
			TNT1 A 1
			{
				A_SpawnParticle("FF1111", SPF_RELATIVE | SPF_FULLBRIGHT, 1, ParticleSize, startalphaf: Lifetime / DefaultLifeTime);
				A_ChangeVelocity(frandom(-0.10, 0.10), frandom(-0.10, 0.10), frandom(-0.10, 0.10), CVF_RELATIVE);
				if (Lifetime-- < 0) Destroy();
			}
			Loop;
	}
}
