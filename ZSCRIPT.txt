version "4.0"

class RedlineHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'PlasmaReplaces':
				if (random[redrand]() <= 32)
				{
					e.Replacement = "RedlineRandom";
				}
				break;
		}
	}

	override void WorldThingSpawned(WorldEvent e)
	{
		let RedlineAmmo = HDBattery(e.Thing);
		if (RedlineAmmo)
		{
			RedlineAmmo.ItemsThatUseThis.Push("HDRedline");
		}
	}
}

class HDRedline : HDCellWeapon
{
	enum RedlineFlags
	{
		RDF_HeatSink = 1,
		RDF_Scope = 2,
		RDF_Capacitor = 4,
		RDF_Resonator = 8,
		RDF_Overheated = 16,
	}

	enum RedlineProperties
	{
		RDProp_Flags,
		RDProp_Battery,

		// [Ace] Charge(F)irst and Charge(L)ast.
		// This is actually the damage of each charge. The number of charges is calculated by checking if Damage > 0;
		RDProp_ChargeF,
		RDProp_ChargeL = RDProp_ChargeF + MaxCharges,

		RDProp_LoadType,
		RDProp_Rpm,
		RDProp_Heat
	}

	override void PostBeginPlay()
	{
		weaponspecial = 1337; // [Ace] UaS sling compatibility.

		Super.PostBeginPlay();
	}

	override void Tick()
	{
		double Rpm = WeaponStatus[RDProp_Rpm];
		if (Rpm > MaxRpm * 1.1)
		{
			Rpm *= 0.96;
		}
		if (!IsRevving)
		{
			Rpm -= 1;
			Rpm *= 0.984;
		}
		WeaponStatus[RDProp_Rpm] = int(max(0, Rpm));

		if (WeaponStatus[RDProp_Heat] > 0)
		{
			if (WeaponStatus[RDProp_Flags] & RDF_Overheated)
			{
				WeaponStatus[RDProp_Heat]--;
			}
			if (WeaponStatus[RDProp_Flags] & RDF_HeatSink)
			{
				WeaponStatus[RDProp_Heat]--;
			}
			DrainHeat(RDProp_Heat, 10, 0.5, 1.5, 0.6);
		}
		if (WeaponStatus[RDProp_Heat] <= 0)
		{
			WeaponStatus[RDProp_Flags] &= ~RDF_Overheated;
			WeaponStatus[RDProp_Heat] = 0;
		}

		if (owner)
		{
			if (Rpm > 0)
			{
				owner.A_StartSound("Redline/Revving", 100, CHANF_LOOPING);
			}
			double RpmFactor = Rpm / double(MaxRpm);
			owner.A_SoundPitch(100, 0.6 + (RpmFactor * 0.7) + 0.15 * (A_GetCharges() - 1));
			owner.A_SoundVolume(100, min(0.5, RpmFactor * 1.5));
			if (RpmFactor ~== 0)
			{
				owner.A_StopSound(100);
			}
		}

		Super.Tick();
	}

	override void DetachFromOwner()
	{
		owner.A_StopSound(100);
		Super.DetachFromOwner();
	}

	override void OnDestroy()
	{
		if (owner)
		{
			owner.A_StopSound(100);
		}
		Super.OnDestroy();
	}

	override void DoEffect()
	{
		if (!owner || !owner.player || owner.player.ReadyWeapon != self)
		{
			return;
		}

		// Console.Printf("\c[Green]RPM:\c- %i \c[Green]Damage:\c- %i, %i, %i, %i \c[Green]Tier:\c- %i \c[Green]Heat:\c- %i",
		// 	WeaponStatus[RDProp_Rpm],
		// 	WeaponStatus[RDProp_ChargeF],
		// 	WeaponStatus[RDProp_ChargeF + 1],
		// 	WeaponStatus[RDProp_ChargeF + 2],
		// 	WeaponStatus[RDProp_ChargeF + 3],
		// 	A_GetDamageTier(),
		// 	WeaponStatus[RDProp_Heat]);

		Super.DoEffect();
	}

	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner , bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override double GunMass() { return WeaponStatus[RDProp_Battery] >= 0 ? 12 : 11; }
	override double WeaponBulk()
	{
		return 122
		+ (WeaponStatus[RDProp_Battery] >= 0 ? ENC_BATTERY_LOADED : 0)
		+ (WeaponStatus[RDProp_Flags] & RDF_Scope ? 6 : 0);
	}
	override string, double GetPickupSprite() { return WeaponStatus[RDProp_Flags] & RDF_Scope ? "RDSGZ0" : "RDNGZ0", 1.0; }
	override void InitializeWepStats(bool idfa)
	{
		WeaponStatus[RDProp_Battery] = 30;
		WeaponStatus[RDProp_ChargeF] = random(90, 120);
		WeaponStatus[RDProp_ChargeF + 1] = random(90, 120);
		WeaponStatus[RDProp_ChargeF + 2] = random(90, 120);
		if (WeaponStatus[RDProp_Flags] & RDF_Capacitor)
		{
			WeaponStatus[RDProp_ChargeF + 3] = random(90, 120);
		}
	}
	override void LoadoutConfigure(string input)
	{
		if (GetLoadoutVar(input, "sink", 1) > 0)
		{
			WeaponStatus[RDProp_Flags] |= RDF_HeatSink;
		}
		if (GetLoadoutVar(input, "cap", 1) > 0)
		{
			WeaponStatus[RDProp_Flags] |= RDF_Capacitor;
		}
		if (GetLoadoutVar(input, "scope", 1) > 0)
		{
			WeaponStatus[RDProp_Flags] |= RDF_Scope;
		}
		if (GetLoadoutVar(input, "resonator", 1) > 0)
		{
			WeaponStatus[RDProp_Flags] |= RDF_Resonator;
		}

		InitializeWepStats(false);
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Shoot\n"
		..WEPHELP_ALTFIRE.."  Work the bolt\n"
		..WEPHELP_ALTFIRE.." (hold)+"..WEPHELP_RELOAD.."  Load/Unload battery\n"
		..WEPHELP_ALTFIRE.." (hold)+"..WEPHELP_UNLOAD.."  Unload battery";
	}

	override string PickupMessage()
	{
		string CapStr = WeaponStatus[RDProp_Flags] & RDF_Capacitor ? "high-capacity " : "";
		string ResStr = WeaponStatus[RDProp_Flags] & RDF_Resonator ? "resonating " : "";
		string SinkStr = WeaponStatus[RDProp_Flags] & RDF_HeatSink ? "heat-sinked " : "";
		return String.Format("You got the %s%s%sRDL-N3 'Redline' bolt-action thermal lance.", CapStr, ResStr, SinkStr);
	}

	protected clearscope int GetRealBatteryCharge(bool useUpper)
	{
		if (WeaponStatus[RDProp_Battery] == -1)
		{
			return -1;
		}
		double FracCharge = WeaponStatus[RDProp_Battery] / 1.5;
		return int(useUpper ? ceil(FracCharge) : floor(FracCharge));
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		if (sb.HudLevel == 1)
		{
			sb.DrawBattery(-54, -4, sb.DI_SCREEN_CENTER_BOTTOM, reloadorder: true);
			sb.DrawNum(hpl.CountInv("HDBattery"), -46, -8, sb.DI_SCREEN_CENTER_BOTTOM);
		}

		if (hdw.WeaponStatus[RDProp_Flags] & RDF_Overheated)
		{
			sb.DrawString(sb.pNewSmallFont, "OVERHEAT", (-24, -25), sb.DI_TEXT_ALIGN_RIGHT | sb.DI_SCREEN_CENTER_BOTTOM, Font.CR_RED, scale: (0.5, 0.5));
		}

		bool NoEngine = hdw.WeaponStatus[RDProp_Flags] & RDF_Resonator;

		sb.DrawWepNum(hdw.WeaponStatus[RDProp_Heat], MaxHeat * (AceCore.CheckForItem(self, "HDGungnir") ? 1.5 : 1.0), posy: NoEngine ? -8 : -11, alwaysprecise: true);

		int BatteryCharge = GetRealBatteryCharge(true);
		if (BatteryCharge > 0)
		{
			if (!NoEngine)
			{
				sb.DrawWepNum(hdw.WeaponStatus[RDProp_Rpm], MaxRpm, posy: -8, alwaysprecise: true);
				sb.Fill(Color(255, 32, 192, 32), -16 + -22 * Notches[0], -10, -2, 2, sb.DI_SCREEN_CENTER_BOTTOM);
				sb.Fill(Color(255, 192, 192, 32), -16 + -22 * Notches[1], -10, -2, 2, sb.DI_SCREEN_CENTER_BOTTOM);
				sb.Fill(Color(255, 192, 32, 32), -16 + -22 * Notches[2], -10, -2, 2, sb.DI_SCREEN_CENTER_BOTTOM);
			}

			sb.DrawWepNum(BatteryCharge, 20, posy: -5);
		}
		else if (BatteryCharge == 0)
		{
			sb.DrawString(sb.mAmountFont, "00000", (-16, -10), sb.DI_TEXT_ALIGN_RIGHT | sb.DI_SCREEN_CENTER_BOTTOM, Font.CR_DARKGRAY);
		}

		for (int i = 0; i < A_GetCharges(); ++i)
		{
			if (NoEngine)
			{
				sb.DrawRect(-21 - 6 * i, -4, 5, 2);
			}
			else
			{
				sb.Fill(GetChargeColor(hdw.WeaponStatus[RDProp_ChargeF + i]), -21 - 6 * i, -4, 5, 2, sb.DI_SCREEN_CENTER_BOTTOM);
			}
		}
	}

	override void DrawSightPicture(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl, bool sightbob, vector2 bob, double fov, bool scopeview, actor hpc, string whichdot)
	{
		int cx, cy, cw, ch;
		int ScaledYOffset = 48;
		int ScaledWidth = 89;

		[cx, cy, cw, ch] = Screen.GetClipRect();
		sb.SetClipRect(-16 + bob.x, -4 + bob.y, 32, 16, sb.DI_SCREEN_CENTER);
		vector2 bob2 = bob * 2;
		bob2.y = clamp(bob2.y, -8, 8);
		sb.DrawImage("REDFRONT", bob2, sb.DI_SCREEN_CENTER | sb.DI_ITEM_TOP, alpha: 0.9, scale: (1, 0.6));
		sb.SetClipRect(cx, cy, cw, ch);
		sb.DrawImage("REDBACK", bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_TOP, scale: (1.25, 0.85));

		if (hdw.WeaponStatus[RDProp_Flags] & RDF_Scope && scopeview)
		{
			TexMan.SetCameraToTexture(hpc, "REDLNCAM", 4);
			sb.DrawImage("REDLNCAM", (0, ScaledYOffset) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER);
			sb.DrawImage("RDLNSCOP", (0, ScaledYOffset) + bob, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER);
			bob2 *= 3;
			double DotOffset = max(abs(bob2.x), abs(bob2.y));
			if (DotOffset < 20)
			{
				sb.DrawImage("RDLNSGHT", (0, ScaledYOffset) + bob2 * 3, sb.DI_SCREEN_CENTER | sb.DI_ITEM_CENTER, alpha: 0.8 - DotOffset * 0.12);
			}
		}
	}

	private action void A_CheckOverheat()
	{
		if (invoker.WeaponStatus[RDProp_Heat] > MaxHeat * (AceCore.CheckForItem(self, "HDGungnir") ? 1.5 : 1.0))
		{
			invoker.WeaponStatus[RDProp_Flags] |= RDF_Overheated;
			A_StartSound("Redline/Overload", 6);
		}
	}

	private clearscope action int A_GetCharges()
	{
		int Count = 0;
		for (int i = RDProp_ChargeF; i <= RDProp_ChargeL; ++i)
		{
			if (invoker.WeaponStatus[i] > 0)
			{
				Count++;
			}
		}
		return Count;
	}

	private clearscope action int A_GetDamageTier()
	{
		int Tier = 0;
		int Rpm = invoker.WeaponStatus[RDProp_Rpm];
		for (int i = 0; i < invoker.Notches.Size(); ++i)
		{
			if (Rpm >= int(MaxRpm * invoker.Notches[i]))
			{
				Tier++;
			}
		}
		return Tier;
	}

	private clearscope Color GetChargeColor(int dmg)
	{
		Color Cols[] =
		{
			Color(255, 32, 192, 32),
			Color(255, 192, 192, 32),
			Color(255, 192, 128, 32),
			Color(255, 192, 32, 32)
		};

		for (int i = 0; i <= Notches.Size(); ++i)
		{
			double exp = 1.0 + DamageExp * i;
			if (dmg >= MinDamage ** exp && dmg <= MaxDamage ** exp)
			{
				return Cols[i];
			}
		}
		return 0;
	}

	private action void A_AddCharge(int dmg)
	{
		for (int i = RDProp_ChargeF; i <= RDProp_ChargeL; ++i)
		{
			if (invoker.WeaponStatus[i] == 0)
			{
				invoker.WeaponStatus[i] = dmg;
				break;
			}
		}
	}

	private action int A_TakeCharge()
	{
		for (int i = RDProp_ChargeL; i >= RDProp_ChargeF; --i)
		{
			if (invoker.WeaponStatus[i] > 0)
			{
				int dmg = invoker.WeaponStatus[i];
				invoker.WeaponStatus[i] = 0;
				return dmg;
			}
		}
		return 0;
	}

	const MaxCharges = 3;
	static const double Notches[] = { 0.2, 0.6, 0.9 };
	const MaxRpm = 1200;
	const MaxHeat = 300;
	const MinDamage = 90;
	const MaxDamage = 120;
	const DamageExp = 0.06;

	private bool HasFired;
	private bool IsRevving;

	Default
	{
		-HDWEAPON.FITSINBACKPACK
		Weapon.SelectionOrder 300;
		Weapon.SlotNumber 6;
		Weapon.SlotPriority 1.5;
		HDWeapon.BarrelSize 35, 1.5, 2;
		Scale 0.6;
		Tag "RDL-N3 'Redline' Thermal Lance";
		HDWeapon.Refid "rdl";
	}

	States
	{
		Spawn:
			RDSG Z 0 NoDelay A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG Z 0;
			#### Z -1;
			Stop;
		Ready:
			RDSG A 0 A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG A 0;
			#### A 1
			{
				invoker.IsRevving = false;
				if (!PressingFire())
				{
					invoker.HasFired = false;
				}
				A_WeaponReady(WRF_ALL | (invoker.HasFired ? WRF_NOPRIMARY : 0));
			}
			Goto ReadyEnd;
		Select0:
			RDSG A 0 A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG A 0;
			#### A 0;
			Goto Select0Big;
		Deselect0:
			RDSG A 0 A_JumpIf(invoker.WeaponStatus[RDProp_Flags] & RDF_Scope, 2);
			RDNG A 0;
			#### A 0;
			Goto Deselect0Big;
		User3:
			#### A 0 A_MagManager("HDBattery");
			Goto Ready;
		Fire:
			#### A 1
			{
				if (invoker.WeaponStatus[RDProp_Flags] & RDF_Overheated)
				{
					A_StartSound("Redline/Overheated", CHAN_WEAPON);
					SetWeaponState('Nope');
					return;
				}

				if (A_GetCharges() > 0 && !invoker.HasFired)
				{
					invoker.HasFired = true;
					SetWeaponState('Shoot');
					return;
				}
			}
			Goto Ready;
		Shoot:
			#### F 1 Bright Offset(0, 42)
			{
				A_Light0();
				A_StartSound("Redline/Fire", CHAN_WEAPON);

				invoker.WeaponStatus[RDProp_Rpm] += random(50, 80);
				int Rpm = invoker.WeaponStatus[RDProp_Rpm];

				int ChargeDamage = A_TakeCharge();
				A_RailAttack(ChargeDamage, 0, false, "", "", RGF_NOPIERCING | RGF_NORANDOMPUFFZ | RGF_SILENT, 0, "RedlineRayImpact", 0, 0, 12600, 0, 4.0, 0, "RedlineRaySmoke");
				
				invoker.WeaponStatus[RDProp_Heat] += int(ChargeDamage / 4 * frandom(0.925, 1.05));
				A_CheckOverheat();

				A_AlertMonsters();
				A_MuzzleClimb(0, 0, -0.2, -0.8, -frandom(0.5, 0.9), -frandom(0.5, 0.9), -frandom(0.5, 0.9), -frandom(0.5, 0.9));
			}
			#### A 2 Offset(0, 38);
			#### A 1 Offset(0, 34);
			Goto Ready;
		AltFire:
			#### A 1 Offset(0, 34) A_WeaponBusy();
			#### B 1 Offset(4, 38);
			#### B 1 Offset(0, 34);
			#### B 0 A_Refire('BoltPull');
			Goto Ready;
		BoltPull:
			#### C 2 Offset(4, 38) A_StartSound("Redline/BoltBack", 8, CHANF_OVERLAP);
			#### D 1 Offset(6, 42)
			{
				if (GunBraced())
				{
					A_MuzzleClimb(frandom(-0.1, 0.3), frandom(-0.1, 0.3));
				}
				else
				{
					A_MuzzleClimb(frandom(-0.2, 0.8), frandom(-0.4, 0.8));
				}
				if (invoker.WeaponStatus[RDProp_Battery] == 0)
				{
					A_StartSound("Redline/Eject", 9, pitch: 0.7);
					Actor Mag = HDMagAmmo.SpawnMag(self, "HDBattery", 0);
					Mag.Angle = Angle;
					Mag.A_ChangeVelocity(-0.75, -1.5, 3.5, CVF_RELATIVE);
					invoker.WeaponStatus[RDProp_Battery] = -1;
				}
				invoker.HasFired = false;
			}
			#### E 2 Offset(6, 42);
			#### E 1 Offset(6, 42) A_WeaponReady(WRF_NOFIRE);
			#### E 0 A_Refire("AltHold");
			Goto AltHoldEnd;
		AltHold:
			#### E 1 A_WeaponReady(WRF_NOFIRE);
			#### E 1
			{
				A_ClearRefire();
				if ((PressingReload() || PressingUnload()) && invoker.WeaponStatus[RDProp_Battery] >= 0)
				{
					invoker.WeaponStatus[RDProp_LoadType] = 0; // [Ace] Unload.
					SetWeaponState('LoadChamber');
					return;
				}
				else if (PressingReload() && CheckInventory("HDBattery", 1))
				{
					invoker.WeaponStatus[RDProp_LoadType] = 1;
					SetWeaponState('LoadChamber');
					return;
				}

				if (!(invoker.WeaponStatus[RDProp_Flags] & RDF_Resonator) && invoker.WeaponStatus[RDProp_Battery] > 0)
				{
					invoker.IsRevving = true;
					int Rpm = invoker.WeaponStatus[RDProp_Rpm];
					invoker.WeaponStatus[RDProp_Rpm] = Rpm + int((2 ** (Rpm * 0.0016)) * 10);
				}

				if (PressingAltFire())
				{
					SetWeaponState('AltHold');
					return;
				}
			}
		AltHoldEnd:
			#### D 2
			{
				A_StartSound("Redline/BoltFwd", 8, CHANF_OVERLAP);
				if (invoker.WeaponStatus[RDProp_Battery] > 0 && A_GetCharges() < MaxCharges + (invoker.WeaponStatus[RDProp_Flags] & RDF_Capacitor ? 1 : 0))
				{
					A_StartSound("Redline/Charge", 9, pitch: 0.85);
					bool NoEngine = invoker.WeaponStatus[RDProp_Flags] & RDF_Resonator;
					if (!NoEngine)
					{
						A_AddCharge(int(random(MinDamage, MaxDamage) ** (1.0 + DamageExp * A_GetDamageTier())));
					}
					else
					{
						A_AddCharge(int(random(MinDamage, MaxDamage) ** (1.0 + DamageExp * A_GetCharges())));
					}
					invoker.WeaponStatus[RDProp_Battery]--;
					invoker.IsRevving = false;
				}
			}
			#### C 2;
			#### B 2 Offset(2, 36)
			{
				A_Refire("AltHold");
				A_WeaponReady(WRF_NOFIRE);
				A_WeaponBusy(false);
			}
			Goto Ready;
		LoadChamber:
			#### E 1 Offset(2, 36) A_ClearRefire();
			#### E 1 Offset(3, 38);
			#### E 1 Offset(5, 42);
			#### E 1 Offset(8, 48) A_StartSound("weapons/pocket", 9);
			#### E 1 Offset(9, 52) A_MuzzleClimb(frandom(-0.2, 0.2), 0.2, frandom(-0.2, 0.2), 0.2, frandom(-0.2, 0.2), 0.2);
			#### E 2 Offset(8, 60);
			#### E 2 Offset(7, 72);
			#### E 2 Offset(6, 80);
			#### E 15;
			#### E 4
			{
				switch (invoker.WeaponStatus[RDProp_LoadType])
				{
					case 0:
						int BatteryCharge = invoker.GetRealBatteryCharge(false); // [Ace] Lose fractions if you take out a non-empty battery.
						invoker.WeaponStatus[RDProp_Battery] = -1;
						if (A_JumpIfInventory("HDBattery", 0, "null"))
						{
							HDMagAmmo.SpawnMag(self, "HDBattery", BatteryCharge);
						}
						else
						{
							HDMagAmmo.GiveMag(self, "HDBattery", BatteryCharge);
						}
						A_StartSound("Redline/CellOut", 10);
						break;
					case 1:
						let Battery = HDMagAmmo(FindInventory("HDBattery"));
						if (Battery && Battery.Amount > 0)
						{
							invoker.WeaponStatus[RDProp_Battery] = int(Battery.TakeMag(true) * 1.5);
							A_StartSound("Redline/CellIn", 10);
						}
						break;
				}
			}
			#### E 2 Offset(6, 80);
			#### E 2 Offset(7, 72);
			#### E 2 Offset(8, 60);
			#### E 1 Offset(7, 52);
			#### E 1 Offset(5, 42);
			#### E 1 Offset(3, 38);
			#### E 1 Offset(3, 35);
			Goto AltHold;
	}
}

class RedlineRandom : IdleDummy
{
	States
	{
		Spawn:
			TNT1 A 0 NoDelay
			{
				A_SpawnItemEx("HDBattery", -3,flags: SXF_NOCHECKPOSITION);
				let wpn = HDRedline(Spawn("HDRedline", pos, ALLOW_REPLACE));
				if (!wpn)
				{
					return;
				}

				wpn.special = special;
				for (int i = 0; i < 5; ++i)
				{
					wpn.Args[i] = Args[i];
				}
				if (!random(0, 3))
				{
					wpn.WeaponStatus[wpn.RDProp_Flags] |= wpn.RDF_HeatSink;
				}
				if (!random(0, 3))
				{
					wpn.WeaponStatus[wpn.RDProp_Flags] |= wpn.RDF_Capacitor;
				}
				if (!random(0, 3))
				{
					wpn.WeaponStatus[wpn.RDProp_Flags] |= wpn.RDF_Scope;
				}
				if (!random(0, 3))
				{
					wpn.WeaponStatus[wpn.RDProp_Flags] |= wpn.RDF_Resonator;
				}

				wpn.InitializeWepStats(false);
			}
			Stop;
	}
}

class RedlineRayImpact : HDActor
{
	Default
	{
		+NODAMAGETHRUST
		+FORCEDECAL
		+PUFFGETSOWNER
		+ALWAYSPUFF
		+PUFFONACTORS
		+NOINTERACTION
		+BLOODLESSIMPACT
		+FORCERADIUSDMG
		+NOBLOOD
		Decal "RedlineScorch";
		DamageType "Thermal";
	}

	States
	{
		Spawn:
			TNT1 A 5 NoDelay
			{
				A_Explode(random(15, 30), 20, XF_HURTSOURCE, false);
				A_StartSound("Redline/Impact");

				for (int i = 0; i < 30; ++i)
				{
					double pitch = frandom(-85.0, 85.0);
					A_SpawnParticle(0xFF1111, SPF_RELATIVE | SPF_FULLBRIGHT, random(10, 20), random(5, 8), random(0, 359), random(0, 4), 0, 0, random(1, 5) * cos(pitch), 0, random(1, 5) * sin(pitch), 0, 0, -0.5);
				}
			}
			Stop;
	}
}

class RedlineRaySmoke : Actor
{
	override void PostBeginPlay()
	{
		if (!random(0, 2))
		{
			A_SpawnItemEx("RedlineRaySmokeParticle");
		}

		A_SetRoll(random(0, 360));

		Super.PostBeginPlay();
	}

	Default
	{
		StencilColor "FF1111";
		RenderStyle "Stencil";
		+NOINTERACTION
		+ROLLSPRITE
		Alpha 2.0;
		Scale 0.005;
	}

	States
	{
		Spawn:
			RDSM K 1 Bright
			{
				A_FadeOut(0.1);
				A_SetScale(Scale.X + 0.0001);
				A_ChangeVelocity(frandom(-0.0025, 0.0025), frandom(-0.0025, 0.0025), frandom(-0.0025, 0.0025), CVF_RELATIVE);
			}
			Loop;
	}
}

class RedlineRaySmokeParticle : Actor
{
	override void PostBeginPlay()
	{
		Lifetime = DefaultLifeTime = random(25, 40);
		ParticleSize = frandom(2.0, 3.0);

		Super.PostBeginPlay();
	}

	Default
	{
		+NOINTERACTION
	}

	double Lifetime;
	double DefaultLifeTime;
	double ParticleSize;

	States
	{
		Spawn:
			TNT1 A 1
			{
				A_SpawnParticle("FF1111", SPF_RELATIVE | SPF_FULLBRIGHT, 1, ParticleSize, startalphaf: Lifetime / DefaultLifeTime);
				A_ChangeVelocity(frandom(-0.10, 0.10), frandom(-0.10, 0.10), frandom(-0.10, 0.10), CVF_RELATIVE);
				if (Lifetime-- < 0) Destroy();
			}
			Loop;
	}
}
